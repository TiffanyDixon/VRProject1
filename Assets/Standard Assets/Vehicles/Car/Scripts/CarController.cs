using System;
using UnityEngine;

namespace UnityStandardAssets.Vehicles.Car
{
    internal enum CarDriveType
    {
        FrontWheelDrive,
        RearWheelDrive,
        FourWheelDrive
    }

    internal enum SpeedType
    {
        MPH,
        KPH
    }

    public class CarController : MonoBehaviour
	{

		public bool planeMode = false;

		public int carWeight = 10000;
		public int planeWeight = 100;

		[SerializeField] private CarDriveType m_CarDriveType = CarDriveType.FourWheelDrive;
		[SerializeField] private WheelCollider[] m_WheelColliders = new WheelCollider[4];
		[SerializeField] private GameObject[] m_WheelMeshes = new GameObject[4];
		[SerializeField] private WheelEffects[] m_WheelEffects = new WheelEffects[4];
		[SerializeField] private Vector3 m_CentreOfMassOffset;
		[SerializeField] private float m_MaximumSteerAngle;
		[Range(0, 1)] [SerializeField] private float m_SteerHelper; // 0 is raw physics , 1 the car will grip in the direction it is facing
		[Range(0, 1)] [SerializeField] private float m_TractionControl; // 0 is no traction control, 1 is full interference
		[SerializeField] private float m_FullTorqueOverAllWheels;
		[SerializeField] private float m_ReverseTorque;
		[SerializeField] private float m_MaxHandbrakeTorque;
		[SerializeField] private float m_Downforce = 100f;
		[SerializeField] private SpeedType m_SpeedType;
		[SerializeField] private float m_Topspeed = 200;
		[SerializeField] private static int NoOfGears = 5;
		[SerializeField] private float m_RevRangeBoundary = 1f;
		[SerializeField] private float m_SlipLimit;
		[SerializeField] private float m_BrakeTorque;






		//Begin plane transplant
		[SerializeField] private float m_MaxEnginePower = 40f;        // The maximum output of the engine.
		[SerializeField] private float m_Lift = 0.002f;               // The amount of lift generated by the aeroplane moving forwards.
		[SerializeField] private float m_ZeroLiftSpeed = 300;         // The speed at which lift is no longer applied.
		[SerializeField] private float m_RollEffect = 1f;             // The strength of effect for roll input.
		[SerializeField] private float m_PitchEffect = 1f;            // The strength of effect for pitch input.
		[SerializeField] private float m_YawEffect = 0.2f;            // The strength of effect for yaw input.
		[SerializeField] private float m_BankedTurnEffect = 0.5f;     // The amount of turn from doing a banked turn.
		[SerializeField] private float m_AerodynamicEffect = 0.02f;   // How much aerodynamics affect the speed of the aeroplane.
		[SerializeField] private float m_AutoTurnPitch = 0.5f;        // How much the aeroplane automatically pitches when in a banked turn.
		[SerializeField] private float m_AutoRollLevel = 0.2f;        // How much the aeroplane tries to level when not rolling.
		[SerializeField] private float m_AutoPitchLevel = 0.2f;       // How much the aeroplane tries to level when not pitching.
		[SerializeField] private float m_AirBrakesEffect = 3f;        // How much the air brakes effect the drag.
		[SerializeField] private float m_ThrottleChangeSpeed = 0.3f;  // The speed with which the throttle changes.
		[SerializeField] private float m_DragIncreaseFactor = 0.001f; // how much drag should increase with speed.



		public float Altitude { get; private set; }                     // The aeroplane's height above the ground.
		public float Throttle { get; private set; }                     // The amount of throttle being used.
		public bool AirBrakes { get; private set; }                     // Whether or not the air brakes are being applied.
		public float ForwardSpeed { get; private set; }                 // How fast the aeroplane is traveling in it's forward direction.
		public float EnginePower { get; private set; }                  // How much power the engine is being given.
		public float MaxEnginePower{ get { return m_MaxEnginePower; }}    // The maximum output of the engine.
		public float RollAngle { get; private set; }
		public float PitchAngle { get; private set; }
		public float RollInput { get; private set; }
		public float PitchInput { get; private set; }
		public float YawInput { get; private set; }
		public float ThrottleInput { get; private set; }

		private float m_OriginalDrag;         // The drag when the scene starts.
		private float m_OriginalAngularDrag;  // The angular drag when the scene starts.
		private float m_AeroFactor;
		private bool m_Immobilized = false;   // used for making the plane uncontrollable, i.e. if it has been hit or crashed.
		private float m_BankedTurnAmount;

		//End Plane transplant


		private Quaternion[] m_WheelMeshLocalRotations;
		private Vector3 m_Prevpos, m_Pos;
		private float m_SteerAngle;
		private int m_GearNum;
		private float m_GearFactor;
		private float m_OldRotation;
		private float m_CurrentTorque;
		private Rigidbody m_Rigidbody;
		private const float k_ReversingThreshold = 0.01f;

		public bool Skidding { get; private set; }
		public float BrakeInput { get; private set; }
		public float CurrentSteerAngle{ get { return m_SteerAngle; }}
		public float CurrentSpeed{ get { return m_Rigidbody.velocity.magnitude*2.23693629f; }}
		public float MaxSpeed{get { return m_Topspeed; }}
		public float Revs { get; private set; }
		public float AccelInput { get; private set; }

		// Use this for initialization
		private void Start()
		{
			m_WheelMeshLocalRotations = new Quaternion[4];
			for (int i = 0; i < 4; i++)
			{
				m_WheelMeshLocalRotations[i] = m_WheelMeshes[i].transform.localRotation;
			}
			m_WheelColliders[0].attachedRigidbody.centerOfMass = m_CentreOfMassOffset;

			m_MaxHandbrakeTorque = float.MaxValue;

			m_Rigidbody = GetComponent<Rigidbody>();
			m_CurrentTorque = m_FullTorqueOverAllWheels - (m_TractionControl*m_FullTorqueOverAllWheels);
			m_OriginalDrag = m_Rigidbody.drag;
			m_OriginalAngularDrag = m_Rigidbody.angularDrag;

			if (planeMode) {
				m_Rigidbody.mass = planeWeight;
			} else {
				m_Rigidbody.mass = carWeight;
			}
		}


		public void Move(float rollInput, float pitchInput, float yawInput, float throttleInput, bool airBrakes)
		{
			if (planeMode) {
				RollInput = rollInput;
				PitchInput = pitchInput;
				YawInput = yawInput;
				ThrottleInput = throttleInput;
				AirBrakes = airBrakes;

				ClampInputs ();

				CalculateRollAndPitchAngles ();

				AutoLevel ();

				CalculateForwardSpeed ();

				ControlThrottle ();

				CalculateDrag ();

				CaluclateAerodynamicEffect ();

				CalculateLinearForces ();

				CalculateTorque ();

				CalculateAltitude ();
			}
		}


		public void Move(float steering, float accel, float footbrake, float handbrake)
		{
			if (!planeMode) {
				for (int i = 0; i < 4; i++) {
					Quaternion quat;
					Vector3 position;
					m_WheelColliders [i].GetWorldPose (out position, out quat);
					m_WheelMeshes [i].transform.position = position;
					m_WheelMeshes [i].transform.rotation = quat;
				}

				//clamp input values
				steering = Mathf.Clamp (steering, -1, 1);
				AccelInput = accel = Mathf.Clamp (accel, 0, 1);
				BrakeInput = footbrake = -1 * Mathf.Clamp (footbrake, -1, 0);
				handbrake = Mathf.Clamp (handbrake, 0, 1);

				//Set the steer on the front wheels.
				//Assuming that wheels 0 and 1 are the front wheels.
				m_SteerAngle = steering * m_MaximumSteerAngle;
				m_WheelColliders [0].steerAngle = m_SteerAngle;
				m_WheelColliders [1].steerAngle = m_SteerAngle;

				SteerHelper ();
				ApplyDrive (accel, footbrake);
				CapSpeed ();

				//Set the handbrake.
				//Assuming that wheels 2 and 3 are the rear wheels.
				if (handbrake > 0f) {
					var hbTorque = handbrake * m_MaxHandbrakeTorque;
					m_WheelColliders [2].brakeTorque = hbTorque;
					m_WheelColliders [3].brakeTorque = hbTorque;
				}


				CalculateRevs ();
				GearChanging ();

				AddDownForce ();
				CheckForWheelSpin ();
				TractionControl ();
			} 
		}

		private void GearChanging()
		{
			float f = Mathf.Abs(CurrentSpeed/MaxSpeed);
			float upgearlimit = (1/(float) NoOfGears)*(m_GearNum + 1);
			float downgearlimit = (1/(float) NoOfGears)*m_GearNum;

			if (m_GearNum > 0 && f < downgearlimit)
			{
				m_GearNum--;
			}

			if (f > upgearlimit && (m_GearNum < (NoOfGears - 1)))
			{
				m_GearNum++;
			}
		}


		// simple function to add a curved bias towards 1 for a value in the 0-1 range
		private static float CurveFactor(float factor)
		{
			return 1 - (1 - factor)*(1 - factor);
		}


		// unclamped version of Lerp, to allow value to exceed the from-to range
		private static float ULerp(float from, float to, float value)
		{
			return (1.0f - value)*from + value*to;
		}


		private void CalculateGearFactor()
		{
			float f = (1/(float) NoOfGears);
			// gear factor is a normalised representation of the current speed within the current gear's range of speeds.
			// We smooth towards the 'target' gear factor, so that revs don't instantly snap up or down when changing gear.
			var targetGearFactor = Mathf.InverseLerp(f*m_GearNum, f*(m_GearNum + 1), Mathf.Abs(CurrentSpeed/MaxSpeed));
			m_GearFactor = Mathf.Lerp(m_GearFactor, targetGearFactor, Time.deltaTime*5f);
		}


		private void CalculateRevs()
		{
			// calculate engine revs (for display / sound)
			// (this is done in retrospect - revs are not used in force/power calculations)
			CalculateGearFactor();
			var gearNumFactor = m_GearNum/(float) NoOfGears;
			var revsRangeMin = ULerp(0f, m_RevRangeBoundary, CurveFactor(gearNumFactor));
			var revsRangeMax = ULerp(m_RevRangeBoundary, 1f, gearNumFactor);
			Revs = ULerp(revsRangeMin, revsRangeMax, m_GearFactor);
		}





		private void CapSpeed()
		{
			float speed = m_Rigidbody.velocity.magnitude;
			switch (m_SpeedType)
			{
			case SpeedType.MPH:

				speed *= 2.23693629f;
				if (speed > m_Topspeed)
					m_Rigidbody.velocity = (m_Topspeed/2.23693629f) * m_Rigidbody.velocity.normalized;
				break;

			case SpeedType.KPH:
				speed *= 3.6f;
				if (speed > m_Topspeed)
					m_Rigidbody.velocity = (m_Topspeed/3.6f) * m_Rigidbody.velocity.normalized;
				break;
			}
		}


		private void ApplyDrive(float accel, float footbrake)
		{

			float thrustTorque;
			switch (m_CarDriveType)
			{
			case CarDriveType.FourWheelDrive:
				thrustTorque = accel * (m_CurrentTorque / 4f);
				for (int i = 0; i < 4; i++)
				{
					m_WheelColliders[i].motorTorque = thrustTorque;
				}
				break;

			case CarDriveType.FrontWheelDrive:
				thrustTorque = accel * (m_CurrentTorque / 2f);
				m_WheelColliders[0].motorTorque = m_WheelColliders[1].motorTorque = thrustTorque;
				break;

			case CarDriveType.RearWheelDrive:
				thrustTorque = accel * (m_CurrentTorque / 2f);
				m_WheelColliders[2].motorTorque = m_WheelColliders[3].motorTorque = thrustTorque;
				break;

			}

			for (int i = 0; i < 4; i++)
			{
				if (CurrentSpeed > 5 && Vector3.Angle(transform.forward, m_Rigidbody.velocity) < 50f)
				{
					m_WheelColliders[i].brakeTorque = m_BrakeTorque*footbrake;
				}
				else if (footbrake > 0)
				{
					m_WheelColliders[i].brakeTorque = 0f;
					m_WheelColliders[i].motorTorque = -m_ReverseTorque*footbrake;
				}
			}
		}


		private void SteerHelper()
		{
			for (int i = 0; i < 4; i++)
			{
				WheelHit wheelhit;
				m_WheelColliders[i].GetGroundHit(out wheelhit);
				if (wheelhit.normal == Vector3.zero)
					return; // wheels arent on the ground so dont realign the rigidbody velocity
			}

			// this if is needed to avoid gimbal lock problems that will make the car suddenly shift direction
			if (Mathf.Abs(m_OldRotation - transform.eulerAngles.y) < 10f)
			{
				var turnadjust = (transform.eulerAngles.y - m_OldRotation) * m_SteerHelper;
				Quaternion velRotation = Quaternion.AngleAxis(turnadjust, Vector3.up);
				m_Rigidbody.velocity = velRotation * m_Rigidbody.velocity;
			}
			m_OldRotation = transform.eulerAngles.y;
		}


		// this is used to add more grip in relation to speed
		private void AddDownForce()
		{
			m_WheelColliders[0].attachedRigidbody.AddForce(-transform.up*m_Downforce*
				m_WheelColliders[0].attachedRigidbody.velocity.magnitude);
		}


		// checks if the wheels are spinning and is so does three things
		// 1) emits particles
		// 2) plays tiure skidding sounds
		// 3) leaves skidmarks on the ground
		// these effects are controlled through the WheelEffects class
		private void CheckForWheelSpin()
		{
			// loop through all wheels
			for (int i = 0; i < 4; i++)
			{
				WheelHit wheelHit;
				m_WheelColliders[i].GetGroundHit(out wheelHit);

				// is the tire slipping above the given threshhold
				if (Mathf.Abs(wheelHit.forwardSlip) >= m_SlipLimit || Mathf.Abs(wheelHit.sidewaysSlip) >= m_SlipLimit)
				{
					m_WheelEffects[i].EmitTyreSmoke();

					// avoiding all four tires screeching at the same time
					// if they do it can lead to some strange audio artefacts
					if (!AnySkidSoundPlaying())
					{
						m_WheelEffects[i].PlayAudio();
					}
					continue;
				}

				// if it wasnt slipping stop all the audio
				if (m_WheelEffects[i].PlayingAudio)
				{
					m_WheelEffects[i].StopAudio();
				}
				// end the trail generation
				m_WheelEffects[i].EndSkidTrail();
			}
		}

		// crude traction control that reduces the power to wheel if the car is wheel spinning too much
		private void TractionControl()
		{
			WheelHit wheelHit;
			switch (m_CarDriveType)
			{
			case CarDriveType.FourWheelDrive:
				// loop through all wheels
				for (int i = 0; i < 4; i++)
				{
					m_WheelColliders[i].GetGroundHit(out wheelHit);

					AdjustTorque(wheelHit.forwardSlip);
				}
				break;

			case CarDriveType.RearWheelDrive:
				m_WheelColliders[2].GetGroundHit(out wheelHit);
				AdjustTorque(wheelHit.forwardSlip);

				m_WheelColliders[3].GetGroundHit(out wheelHit);
				AdjustTorque(wheelHit.forwardSlip);
				break;

			case CarDriveType.FrontWheelDrive:
				m_WheelColliders[0].GetGroundHit(out wheelHit);
				AdjustTorque(wheelHit.forwardSlip);

				m_WheelColliders[1].GetGroundHit(out wheelHit);
				AdjustTorque(wheelHit.forwardSlip);
				break;
			}
		}


		private void AdjustTorque(float forwardSlip)
		{
			if (forwardSlip >= m_SlipLimit && m_CurrentTorque >= 0)
			{
				m_CurrentTorque -= 10 * m_TractionControl;
			}
			else
			{
				m_CurrentTorque += 10 * m_TractionControl;
				if (m_CurrentTorque > m_FullTorqueOverAllWheels)
				{
					m_CurrentTorque = m_FullTorqueOverAllWheels;
				}
			}
		}


		private bool AnySkidSoundPlaying()
		{
			for (int i = 0; i < 4; i++)
			{
				if (m_WheelEffects[i].PlayingAudio)
				{
					return true;
				}
			}
			return false;
		}



		private void ClampInputs()
		{
			// clamp the inputs to -1 to 1 range
			RollInput = Mathf.Clamp(RollInput, -1, 1);
			PitchInput = Mathf.Clamp(PitchInput, -1, 1);
			YawInput = Mathf.Clamp(YawInput, -1, 1);
			ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
		}


		private void CalculateRollAndPitchAngles()
		{
			// Calculate roll & pitch angles
			// Calculate the flat forward direction (with no y component).
			var flatForward = transform.forward;
			flatForward.y = 0;
			// If the flat forward vector is non-zero (which would only happen if the plane was pointing exactly straight upwards)
			if (flatForward.sqrMagnitude > 0)
			{
				flatForward.Normalize();
				// calculate current pitch angle
				var localFlatForward = transform.InverseTransformDirection(flatForward);
				PitchAngle = Mathf.Atan2(localFlatForward.y, localFlatForward.z);
				// calculate current roll angle
				var flatRight = Vector3.Cross(Vector3.up, flatForward);
				var localFlatRight = transform.InverseTransformDirection(flatRight);
				RollAngle = Mathf.Atan2(localFlatRight.y, localFlatRight.x);
			}
		}


		private void AutoLevel()
		{
			// The banked turn amount (between -1 and 1) is the sine of the roll angle.
			// this is an amount applied to elevator input if the user is only using the banking controls,
			// because that's what people expect to happen in games!
			m_BankedTurnAmount = Mathf.Sin(RollAngle);
			// auto level roll, if there's no roll input:
			if (RollInput == 0f)
			{
				RollInput = -RollAngle*m_AutoRollLevel;
			}
			// auto correct pitch, if no pitch input (but also apply the banked turn amount)
			if (PitchInput == 0f)
			{
				PitchInput = -PitchAngle*m_AutoPitchLevel;
				PitchInput -= Mathf.Abs(m_BankedTurnAmount*m_BankedTurnAmount*m_AutoTurnPitch);
			}
		}


		private void CalculateForwardSpeed()
		{
			// Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
			var localVelocity = transform.InverseTransformDirection(m_Rigidbody.velocity);
			ForwardSpeed = Mathf.Max(0, localVelocity.z);
		}


		private void ControlThrottle()
		{
			// override throttle if immobilized
			if (m_Immobilized)
			{
				ThrottleInput = -0.5f;
			}

			// Adjust throttle based on throttle input (or immobilized state)
			Throttle = Mathf.Clamp01(Throttle + ThrottleInput*Time.deltaTime*m_ThrottleChangeSpeed);

			// current engine power is just:
			EnginePower = Throttle*m_MaxEnginePower;
		}

		public void switchMode()
		{
			planeMode = !planeMode;

			if (planeMode) {
				m_Rigidbody.mass = planeWeight;
			} else {
				m_Rigidbody.mass = carWeight;
			}
		}

		private void CalculateDrag()
		{
			// increase the drag based on speed, since a constant drag doesn't seem "Real" (tm) enough
			float extraDrag = m_Rigidbody.velocity.magnitude*m_DragIncreaseFactor;
			// Air brakes work by directly modifying drag. This part is actually pretty realistic!
			m_Rigidbody.drag = (AirBrakes ? (m_OriginalDrag + extraDrag)*m_AirBrakesEffect : m_OriginalDrag + extraDrag);
			// Forward speed affects angular drag - at high forward speed, it's much harder for the plane to spin
			m_Rigidbody.angularDrag = m_OriginalAngularDrag*ForwardSpeed;
		}


		private void CaluclateAerodynamicEffect()
		{
			// "Aerodynamic" calculations. This is a very simple approximation of the effect that a plane
			// will naturally try to align itself in the direction that it's facing when moving at speed.
			// Without this, the plane would behave a bit like the asteroids spaceship!
			if (m_Rigidbody.velocity.magnitude > 0)
			{
				// compare the direction we're pointing with the direction we're moving:
				m_AeroFactor = Vector3.Dot(transform.forward, m_Rigidbody.velocity.normalized);
				// multipled by itself results in a desirable rolloff curve of the effect
				m_AeroFactor *= m_AeroFactor;
				// Finally we calculate a new velocity by bending the current velocity direction towards
				// the the direction the plane is facing, by an amount based on this aeroFactor
				var newVelocity = Vector3.Lerp(m_Rigidbody.velocity, transform.forward*ForwardSpeed,
					m_AeroFactor*ForwardSpeed*m_AerodynamicEffect*Time.deltaTime);
				m_Rigidbody.velocity = newVelocity;

				// also rotate the plane towards the direction of movement - this should be a very small effect, but means the plane ends up
				// pointing downwards in a stall
				m_Rigidbody.rotation = Quaternion.Slerp(m_Rigidbody.rotation,
					Quaternion.LookRotation(m_Rigidbody.velocity, transform.up),
					m_AerodynamicEffect*Time.deltaTime);
			}
		}


		private void CalculateLinearForces()
		{
			// Now calculate forces acting on the aeroplane:
			// we accumulate forces into this variable:
			var forces = Vector3.zero;
			// Add the engine power in the forward direction
			forces += EnginePower*transform.forward;
			// The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)
			var liftDirection = Vector3.Cross(m_Rigidbody.velocity, transform.right).normalized;
			// The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps
			// shortly after takeoff, giving the plane less drag, but less lift. Because we don't simulate flaps, this is
			// a simple way of doing it automatically:
			var zeroLiftFactor = Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed);
			// Calculate and add the lift power
			var liftPower = ForwardSpeed*ForwardSpeed*m_Lift*zeroLiftFactor*m_AeroFactor;
			forces += liftPower*liftDirection;
			// Apply the calculated forces to the the Rigidbody
			m_Rigidbody.AddForce(forces);
		}


		private void CalculateTorque()
		{
			// We accumulate torque forces into this variable:
			var torque = Vector3.zero;
			// Add torque for the pitch based on the pitch input.
			torque += PitchInput*m_PitchEffect*transform.right;
			// Add torque for the yaw based on the yaw input.
			torque += YawInput*m_YawEffect*transform.up;
			// Add torque for the roll based on the roll input.
			torque += -RollInput*m_RollEffect*transform.forward;
			// Add torque for banked turning.
			torque += m_BankedTurnAmount*m_BankedTurnEffect*transform.up;
			// The total torque is multiplied by the forward speed, so the controls have more effect at high speed,
			// and little effect at low speed, or when not moving in the direction of the nose of the plane
			// (i.e. falling while stalled)
			m_Rigidbody.AddTorque(torque*ForwardSpeed*m_AeroFactor);
		}


		private void CalculateAltitude()
		{
			// Altitude calculations - we raycast downwards from the aeroplane
			// starting a safe distance below the plane to avoid colliding with any of the plane's own colliders
			var ray = new Ray(transform.position - Vector3.up*10, -Vector3.up);
			RaycastHit hit;
			Altitude = Physics.Raycast(ray, out hit) ? hit.distance + 10 : transform.position.y;
		}


		// Immobilize can be called from other objects, for example if this plane is hit by a weapon and should become uncontrollable
		public void Immobilize()
		{
			m_Immobilized = true;
		}


		// Reset is called via the ObjectResetter script, if present.
		public void Reset()
		{
			m_Immobilized = false;
		}
	}
}
